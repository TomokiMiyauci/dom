{
  "description": "List of patterns that the test passes",

  "passes": {
    "dom/nodes/DOMImplementation-createHTMLDocument.html": [
      {
        "name": "createHTMLDocument(): URL parsing",
        "reason": "HTMLAnchorElement#href getter is not supported"
      }
    ],
    "dom/nodes/Text-constructor.html": [
      {
        "name": "new Text() should get the correct ownerDocument across globals",
        "reason": "Not supported onload event handler attribute"
      },
      {
        "name": "new Text(): prototype chain",
        "reason": "prototype chain"
      }
    ],
    "dom/nodes/Comment-constructor.html": [
      {
        "name": "new Comment() should get the correct ownerDocument across globals",
        "reason": "Not supported onload event handler attribute"
      },
      {
        "name": "new Comment(): prototype chain",
        "reason": "prototype chain"
      }
    ],
    "dom/nodes/Node-appendChild.html": [
      {
        "name": "Appending null to a text node",
        "reason": "compiler error"
      },
      {
        "name": "Appending null to a comment",
        "reason": "compiler error"
      },
      {
        "name": "Appending null to a doctype",
        "reason": "compiler error"
      },
      {
        "name": "WebIDL tests",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/Node-removeChild.html": [
      {
        "name": "Passing a value that is not a Node reference to removeChild should throw TypeError.",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/Node-insertBefore.html": [
      {
        "name": "Calling insertBefore with second argument missing, or other than Node, null, or undefined, must throw TypeError.",
        "reason": "compiler error"
      },
      {
        "name": "Calling insertBefore with a non-Node first argument on a leaf node DocumentType must throw TypeError.",
        "reason": "compiler error"
      },
      {
        "name": "Calling insertBefore with a non-Node first argument on a leaf node Text must throw TypeError.",
        "reason": "compiler error"
      },
      {
        "name": "Calling insertBefore with a non-Node first argument on a leaf node Comment must throw TypeError.",
        "reason": "compiler error"
      },
      {
        "name": "Calling insertBefore with a non-Node first argument on a leaf node ProcessingInstruction must throw TypeError.",
        "reason": "compiler error"
      },
      {
        "name": "Calling insertBefore with a non-Node first argument must throw TypeError.",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/Node-replaceChild.html": [
      {
        "name": "Passing null to replaceChild should throw a TypeError.",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/Document-getElementById.html": [
      {
        "name": "add id attribute via outerHTML",
        "reason": "outerHTML setter is not supported"
      },
      {
        "name": "remove id attribute via outerHTML",
        "reason": "outerHTML setter is not supported"
      }
    ],
    "dom/nodes/Element-tagName.html": [
      {
        "name": "tagName should be updated when changing ownerDocument",
        "reason": "DOMParser text/xml is not supported"
      }
    ],
    "dom/nodes/Document-constructor.html": [
      {
        "name": "new Document(): URL parsing",
        "reason": "HTMLHyperlinkElementUtils href getter is not supported"
      }
    ],
    "dom/nodes/CharacterData-appendData.html": [
      {
        "name": "Text.appendData()",
        "reason": "compiler error"
      },
      {
        "name": "Comment.appendData()",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/CharacterData-substringData.html": [
      {
        "name": "Text.substringData() with too few arguments",
        "reason": "compiler error"
      },
      {
        "name": "Comment.substringData() with too few arguments",
        "reason": "compiler error"
      }
    ],
    "dom/collections/HTMLCollection-as-prototype.html": [
      {
        "name": "HTMLCollection as a prototype should not allow getting .length on the base object",
        "reason": "not supported"
      }
    ],
    "dom/collections/HTMLCollection-supported-property-indices.html": [
      {
        "name": "Trying to delete an indexed property name should never work",
        "reason": "Bug"
      }
    ],
    "dom/collections/HTMLCollection-supported-property-names.html": [
      {
        "name": "Trying to set a non-configurable expando that shadows a named property that gets added later",
        "reason": "Bug"
      }
    ],
    "dom/nodes/Element-insertAdjacentElement.html": [
      {
        "name": "Adding more than one child to document should cause a HierarchyRequestError exception",
        "reason": "style.visibility setter is not supported"
      }
    ],
    "dom/nodes/Element-insertAdjacentText.html": [
      {
        "name": "Adding more than one child to document should cause a HierarchyRequestError exception",
        "reason": "style.visibility setter is not supported"
      }
    ],
    "dom/nodes/Node-normalize.html": [
      {
        "name": "Non-text nodes with empty textContent values.",
        "reason": "DOMParser is not supported text/xml"
      }
    ],
    "dom/ranges/StaticRange-constructor.html": [
      {
        "name": "Construct static range with CDATASection container",
        "reason": "DOMParser is not supported application/xml"
      },
      {
        "name": "Throw on missing or invalid arguments",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/Document-createElement.html": [
      {
        "name": "createElement(\"ınput\") in HTML document",
        "reason": "Bug"
      }
    ],
    "dom/nodes/Document-createElementNS.html": [],
    "dom/nodes/MutationObserver-attributes.html": [
      {
        "name": "attributes HTMLInputElement.type: type update mutation",
        "reason": "HTMLInputElement type setter is not supported"
      }
    ],
    "dom/traversal/NodeIterator.html": [
      {
        "name": "createNodeIterator() with null as arguments",
        "reason": "assign to readonly"
      }
    ],
    "dom/traversal/TreeWalker-basic.html": [
      {
        "name": "Construct a TreeWalker by document.createTreeWalker(root, null, null).",
        "reason": "assign to readonly"
      },

      {
        "name": "Give an invalid root node to document.createTreeWalker().",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/Document-createTreeWalker.html": [
      {
        "name": "Required arguments to createTreeWalker should be required.",
        "reason": "compiler error"
      }
    ],

    "dom/events/Event-type-empty.html": [
      { "name": "Constructor", "reason": "globalThis Event is not supported" }
    ],
    "dom/events/CustomEvent.html": [
      {
        "name": "First parameter to initCustomEvent should be mandatory.",
        "reason": "compiler error"
      }
    ],
    "dom/events/Event-initEvent.html": [
      {
        "name": "First parameter to initEvent should be mandatory.",
        "reason": "compiler error"
      }
    ],
    "dom/ranges/Range-intersectsNode-binding.html": [
      {
        "name": "Calling intersectsNode without an argument or with an invalid argument should throw a TypeError.",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/insert-adjacent.html": [
      {
        "name": "invalid object argument insertAdjacentElement",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/Document-createElement-namespace.html": [
      {
        "name": "Created element's namespace in created XML document by DOMParser ('text/xml')",
        "reason": "DOMParser is not supported that content-type"
      },
      {
        "name": "Created element's namespace in created XML document by DOMParser ('application/xml')",
        "reason": "DOMParser is not supported that content-type"
      },
      {
        "name": "Created element's namespace in created XHTML document by DOMParser ('application/xhtml+xml')",
        "reason": "DOMParser is not supported that content-type"
      },
      {
        "name": "Created element's namespace in created SVG document by DOMParser ('image/svg+xml')",
        "reason": "DOMParser is not supported that content-type"
      }
    ],
    "dom/nodes/DOMImplementation-createDocument.html": [
      {
        "name": "createDocument with missing arguments",
        "reason": "compiler error"
      }
    ],
    "dom/nodes/rootNode.html": [
      {
        "name": "getRootNode() must return context object's shadow-including root if options's composed is true, and context object's root otherwise",
        "reason": "Bug: Shadow root querySelector is wrong"
      }
    ],
    "dom/ranges/Range-adopt-test.html": [
      {
        "name": "Range container's parentless container moved to another document with appendChild: Removing the only element in the range must collapse the range",
        "reason": "TODO: associated document rages is wrong"
      },
      {
        "name": "Parentless range container moved to another document with appendChild: Removing the only element in the range must collapse the range",
        "reason": "TODO: associated document rages is wrong"
      }
    ],
    "dom/nodes/Element-closest.html": [
      {
        "name": "Element.closest with context node 'test11' and selector ':invalid'",
        "reason": "the selector is not supported"
      },

      {
        "name": "Element.closest with context node 'test4' and selector ':has(> :scope)'",
        "reason": "the selector is not supported"
      }
    ],
    "dom/nodes/Element-matches.html": [
      {
        "name": "DIV Element.matches no parameter",
        "reason": "compiler error"
      },
      {
        "name": "NULL Element.matches no parameter",
        "reason": "compiler error"
      },
      {
        "name": "UNDEFINED Element.matches no parameter",
        "reason": "compiler error"
      },
      {
        "name": "Detached Element.matches: Invalid class: .5cm",
        "reason": "selector parser should error that class selector but not"
      },
      {
        "name": "In-document Element.matches: Invalid class: .5cm",
        "reason": "selector parser should error that class selector but not"
      },
      {
        "name": "Detached Element.matches: Undeclared namespace: ns|div",
        "reason": "selector parser should error that selector but not"
      },
      {
        "name": "In-document Element.matches: Undeclared namespace: ns|div",
        "reason": "selector parser should error that selector but not"
      },
      {
        "name": "Detached Element.matches: Undeclared namespace: :not(ns|div)",
        "reason": "selector parser should error that selector but not"
      },
      {
        "name": "In-document Element.matches: Undeclared namespace: :not(ns|div)",
        "reason": "selector parser should error that selector but not"
      },
      {
        "name": "In-document Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with no refNodes): ul[data-中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with no refNodes): ul[data-中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with no refNodes): ul[data-中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Attribute value selector, matching align attribute with value, unclosed bracket (with no refNodes): #attr-value [align=\"center\"",
        "reason": "selector parser is not supported unclosed bracket"
      },
      {
        "name": "Detached Element.matches: Attribute value selector, matching align attribute with value, unclosed bracket (with no refNodes): #attr-value [align=\"center\"",
        "reason": "selector parser is not supported unclosed bracket"
      },
      {
        "name": "Fragment Element.matches: Attribute value selector, matching align attribute with value, unclosed bracket (with no refNodes): #attr-value [align=\"center\"",
        "reason": "selector parser is not supported unclosed bracket"
      },
      {
        "name": "In-document Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with no refNodes): [data-attr-value=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with no refNodes): [data-attr-value=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with no refNodes): [data-attr-value=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with no refNodes): #attr-whitespace [title~=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with no refNodes): #attr-whitespace [title~=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with no refNodes): #attr-whitespace [title~=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Class selector, matching element with class value using non-ASCII characters (1) (with no refNodes): .台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: Class selector, matching element with class value using non-ASCII characters (1) (with no refNodes): .台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: Class selector, matching element with class value using non-ASCII characters (1) (with no refNodes): .台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (with no refNodes): .台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (with no refNodes): .台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (with no refNodes): .台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (1) (with no refNodes): .台北Táiběi.台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (1) (with no refNodes): .台北Táiběi.台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (1) (with no refNodes): .台北Táiběi.台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: ID selector, matching id value using non-ASCII characters (1) (with no refNodes): #台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: ID selector, matching id value using non-ASCII characters (2) (with no refNodes): #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: ID selector, matching id values using non-ASCII characters (1) (with no refNodes): #台北Táiběi, #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: ID selector, matching id value using non-ASCII characters (1) (with no refNodes): #台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: ID selector, matching id value using non-ASCII characters (2) (with no refNodes): #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Detached Element.matches: ID selector, matching id values using non-ASCII characters (1) (with no refNodes): #台北Táiběi, #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: ID selector, matching id value using non-ASCII characters (1) (with no refNodes): #台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: ID selector, matching id value using non-ASCII characters (2) (with no refNodes): #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "Fragment Element.matches: ID selector, matching id values using non-ASCII characters (1) (with no refNodes): #台北Táiběi, #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Attribute presence selector, matching attribute with non-ASCII characters (with refNode Element): ul[data-中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Attribute value selector, matching attribute with value using non-ASCII characters (with refNode Element): [data-attr-value=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Attribute whitespace-separated list selector, matching title attribute with value using non-ASCII characters (with refNode Element): [title~=中文]",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Class selector, matching element with class value using non-ASCII characters (2) (with no refNodes): .台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Class selector, matching multiple elements with class value using non-ASCII characters (1) (with no refNodes): .台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: Class selector, chained, matching element with multiple class values using non-ASCII characters (2) (with no refNodes): .台北Táiběi.台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: ID selector, matching id value using non-ASCII characters (3) (with no refNodes): #台北Táiběi",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: ID selector, matching id value using non-ASCII characters (4) (with no refNodes): #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: ID selector, matching id values using non-ASCII characters (2) (with no refNodes): #台北Táiběi, #台北",
        "reason": "selector parser is not supported non-ASCII character"
      },
      {
        "name": "In-document Element.matches: :nth-of-type selector, matching the third em element (with no refNodes): #pseudo-nth-p1 em:nth-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-of-type selector, matching every second element of their type (with no refNodes): #pseudo-nth-p1 :nth-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with no refNodes): #pseudo-nth-p1 span:nth-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-last-of-type selector, matching the third last em element (with no refNodes): #pseudo-nth-p1 em:nth-last-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type (with no refNodes): #pseudo-nth-p1 :nth-last-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with no refNodes): #pseudo-nth-p1 span:nth-last-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :first-of-type selector, matching the first em element (with no refNodes): #pseudo-nth-p1 em:first-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :first-of-type selector, matching the first of every type of element (with no refNodes): #pseudo-nth-p1 :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :first-of-type selector, matching the first td element in each table row (with no refNodes): #pseudo-nth-table1 tr :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :last-of-type selector, matching the last em elemnet (with no refNodes): #pseudo-nth-p1 em:last-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :last-of-type selector, matching the last of every type of element (with no refNodes): #pseudo-nth-p1 :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :last-of-type selector, matching the last td element in each table row (with no refNodes): #pseudo-nth-table1 tr :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with no refNodes): #pseudo-only :only-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with no refNodes): #pseudo-only em:only-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with no refNodes): #pseudo-link :link, #pseudo-link :visited",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :target pseudo-class selector, matching the element referenced by the URL fragment identifier (with no refNodes): :target",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :lang pseudo-class selector, matching inherited language (with no refNodes): #pseudo-lang-div1:lang(en)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :lang pseudo-class selector, matching specified language with exact value (with no refNodes): #pseudo-lang-div2:lang(fr)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :lang pseudo-class selector, matching specified language with partial value (with no refNodes): #pseudo-lang-div3:lang(en)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :nth-of-type selector, matching the third em element (with no refNodes): #pseudo-nth-p1 em:nth-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :nth-of-type selector, matching every second element of their type (with no refNodes): #pseudo-nth-p1 :nth-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with no refNodes): #pseudo-nth-p1 span:nth-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :nth-last-of-type selector, matching the third last em element (with no refNodes): #pseudo-nth-p1 em:nth-last-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :nth-last-of-type selector, matching every second last element of their type (with no refNodes): #pseudo-nth-p1 :nth-last-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with no refNodes): #pseudo-nth-p1 span:nth-last-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :first-of-type selector, matching the first em element (with no refNodes): #pseudo-nth-p1 em:first-of-type",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :first-of-type selector, matching the first of every type of element (with no refNodes): #pseudo-nth-p1 :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :first-of-type selector, matching the first td element in each table row (with no refNodes): #pseudo-nth-table1 tr :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :last-of-type selector, matching the last em elemnet (with no refNodes): #pseudo-nth-p1 em:last-of-type",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :last-of-type selector, matching the last of every type of element (with no refNodes): #pseudo-nth-p1 :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :last-of-type selector, matching the last td element in each table row (with no refNodes): #pseudo-nth-table1 tr :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with no refNodes): #pseudo-link :link, #pseudo-link :visited",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :lang pseudo-class selector, matching specified language with exact value (with no refNodes): #pseudo-lang-div2:lang(fr)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :lang pseudo-class selector, matching specified language with partial value (with no refNodes): #pseudo-lang-div3:lang(en)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :nth-of-type selector, matching the third em element (with no refNodes): #pseudo-nth-p1 em:nth-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :nth-of-type selector, matching every second element of their type (with no refNodes): #pseudo-nth-p1 :nth-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with no refNodes): #pseudo-nth-p1 span:nth-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :nth-last-of-type selector, matching the third last em element (with no refNodes): #pseudo-nth-p1 em:nth-last-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :nth-last-of-type selector, matching every second last element of their type (with no refNodes): #pseudo-nth-p1 :nth-last-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with no refNodes): #pseudo-nth-p1 span:nth-last-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :first-of-type selector, matching the first em element (with no refNodes): #pseudo-nth-p1 em:first-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :first-of-type selector, matching the first of every type of element (with no refNodes): #pseudo-nth-p1 :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :first-of-type selector, matching the first td element in each table row (with no refNodes): #pseudo-nth-table1 tr :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :last-of-type selector, matching the last em elemnet (with no refNodes): #pseudo-nth-p1 em:last-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :last-of-type selector, matching the last of every type of element (with no refNodes): #pseudo-nth-p1 :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :last-of-type selector, matching the last td element in each table row (with no refNodes): #pseudo-nth-table1 tr :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with no refNodes): #pseudo-only :only-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with no refNodes): #pseudo-only em:only-of-type",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with no refNodes): #pseudo-link :link, #pseudo-link :visited",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :lang pseudo-class selector, matching specified language with exact value (with no refNodes): #pseudo-lang-div2:lang(fr)",
        "reason": "not supported"
      },
      {
        "name": "Fragment Element.matches: :lang pseudo-class selector, matching specified language with partial value (with no refNodes): #pseudo-lang-div3:lang(en)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-of-type selector, matching the third em element (with refNode Element): em:nth-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-of-type selector, matching every second element of their type (with refNode Element): :nth-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-of-type selector, matching every second elemetn of their type, starting from the first (with refNode Element): span:nth-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-last-of-type selector, matching the third last em element (with refNode Element): em:nth-last-of-type(3)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type (with refNode Element): :nth-last-of-type(2n)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :nth-last-of-type selector, matching every second last element of their type, starting from the last (with refNode Element): span:nth-last-of-type(2n-1)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :first-of-type selector, matching the first em element (with refNode Element): em:first-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :first-of-type selector, matching the first of every type of element (with refNode Element): :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :first-of-type selector, matching the first td element in each table row (with refNode Element): tr :first-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :last-of-type selector, matching the last em elemnet (with refNode Element): em:last-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :last-of-type selector, matching the last of every type of element (with refNode Element): :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :last-of-type selector, matching the last td element in each table row (with refNode Element): tr :last-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with refNode Element):  :only-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with refNode Element):  em:only-of-type",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :link and :visited pseudo-class selectors, matching a and area elements with href attributes (with refNode Element):  :link, #pseudo-link :visited",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :lang pseudo-class selector, matching inherited language (1) (with no refNodes): #pseudo-lang-div1:lang(en)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :lang pseudo-class selector, matching specified language with exact value (1) (with no refNodes): #pseudo-lang-div2:lang(fr)",
        "reason": "not supported"
      },
      {
        "name": "In-document Element.matches: :lang pseudo-class selector, matching specified language with partial value (1) (with no refNodes): #pseudo-lang-div3:lang(en)",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :pseudo-only-of-type pseudo-class selector, matching all elements with no siblings of the same type (with no refNodes): #pseudo-only :only-of-type",
        "reason": "not supported"
      },
      {
        "name": "Detached Element.matches: :pseudo-only-of-type pseudo-class selector, matching em elements with no siblings of the same type (with no refNodes): #pseudo-only em:only-of-type",
        "reason": "not supported"
      }
    ]
  }
}
